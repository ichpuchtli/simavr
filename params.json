{"name":"Simavr","tagline":"simavr is a lean, mean and hackable AVR simulator for linux & OSX","body":"simavr - a lean and mean Atmel AVR simulator for linux\r\n======\r\n\r\n_simavr_ is a new AVR simulator for linux, or any platform that uses avr-gcc. It uses \r\navr-gcc's own register definition to simplify creating new targets for supported AVR\r\ndevices. The core was made to be small and compact, and hackable so allow quick \r\nprototyping of an AVR project. The AVR core is now stable for use with parts \r\nwith <= 128KB flash, and with preliminary support for the bigger parts. The \r\nsimulator loads ELF files directly, and there is even a way to specify simulation \r\nparameters directly in the emulated code using an .elf section. You can also \r\nload multipart HEX files.\r\n\r\nSupported IOs\r\n--------------\r\n* _eeprom_\r\n* _watchdog_\r\n* _IO ports_ (including pin interrupts)\r\n* _Timers_, 8 &16 (Normal, CTC and Fast PWM, the overflow interrupt too)\r\n* The _UART_, including tx & rx interrupts (there is a loopback/local echo test mode too)\r\n* _SPI_, master/slave including the interrupt\r\n* _i2c_ Master & Slave\r\n* External _Interrupts_, INT0 and so on.\r\n* _ADC_\r\n* Self-programming (ie bootloaders!)\r\n\r\nEmulated Cores (very easy to add new ones!)\r\n--------------\r\n+ AT90USB162 (with USB!)\r\n+ ATMega1280\r\n+ ATMega128\r\n+ ATMega16M1\r\n+ ATMega164/324/644\r\n+ ATMega48/88/168/328\r\n+ ATMega8\r\n+ ATTiny25/45/85\r\n+ ATTIny44/84\r\n+ ATTiny2313\r\n+ ATTiny13\r\n\r\nExtras:\r\n-------\r\n* fully working _gdb_ support including some pretty cool “passive modes”.\r\n* There is also very easy support for “VCD” (Value Change Dump) that can be visualized \r\ngraphically as “waveforms” with tools like _gtkwave_ (see below).\r\n* There are a few examples of real life firmwares running on simavr, including OpenGL rendering of the display…\r\n* There is support for _Arduino_, but no IDE integration\r\n\r\n*Note:* a mailing list/google group now exists\r\nYou can also join *#simavr* on Freenode for a very quiet IRC channel.\r\n\r\nVCD Support -- built in logic analyzer \r\n-----------\r\n_simavr_ can output most of its pins, firmware variables, interrupts and a few other\r\nthings as signals to be dumped into a file that can be plotted using gtkwave for\r\nfurther, precise analysis.\r\nA firmware can contain instructions for _simavr_ to know what to trace, and the file is\r\nautomatically generated.\r\nExample:\r\n\r\n\tconst struct avr_mmcu_vcd_trace_t _mytrace[]  _MMCU_ = {\r\n\t\t{ AVR_MCU_VCD_SYMBOL(\"UDR0\"), .what = (void*)&UDR0, },\r\n\t\t{ AVR_MCU_VCD_SYMBOL(\"UDRE0\"), .mask = (1 << UDRE0), .what = (void*)&UCSR0A, },\r\n\t};\r\n\r\nWill tell _simavr_ to generate a trace everytime the UDR0 register changes and everytime\r\nthe interrupt is raised (in UCSR0A). The *_MMCU_* tag tells gcc that it needs compiling,\r\nbut it won't be linked in your program, so it takes literally zero bytes, this is a code\r\nsection that is private to _simavr_, it's free!\r\nA program running with these instructions and writing to the serial port will generate\r\na file that will display:\r\n\r\n\t$ ./simavr/run_avr tests/atmega88_example.axf\r\n\tAVR_MMCU_TAG_VCD_TRACE 00c6:00 - UDR0\r\n\tAVR_MMCU_TAG_VCD_TRACE 00c0:20 - UDRE0\r\n\tLoaded 1780 .text\r\n\tLoaded 114 .data\r\n\tLoaded 4 .eeprom\r\n\tStarting atmega88 - flashend 1fff ramend 04ff e2end 01ff\r\n\tatmega88 init\r\n\tavr_eeprom_ioctl: AVR_IOCTL_EEPROM_SET Loaded 4 at offset 0\r\n\tCreating VCD trace file 'gtkwave_trace.vcd'\r\n\tRead from eeprom 0xdeadbeef -- should be 0xdeadbeef..\r\n\tRead from eeprom 0xcafef00d -- should be 0xcafef00d..\r\n\tsimavr: sleeping with interrupts off, quitting gracefully\r\n\r\nAnd when the file is loaded in gtkwave, you see:\r\n![gtkwave](https://github.com/buserror-uk/simavr/raw/master/doc/img/gtkwave1.png)\r\n\r\nYou get a very precise timing breakdown of any change that you add to the trace, down\r\nto the AVR cycle. \r\n\r\nExample:\r\n--------\r\n_simavr_ is really made to be the center for emulating your own AVR projects, not just\r\na debugger, but also the emulating the peripherals you will use in your firmware, so \r\nyou can test and develop offline, and now and then try it on the hardware.\r\n\r\nYou can also use _simavr_ to do test units on your shipping firmware to validate it\r\nbefore you ship a new version, to prevent regressions or mistakes.\r\n\r\n_simavr_ has a few 'complete projects/ that demonstrate this, most of them were made\r\nusing real hardware at some point, and the firmware binary is _exactly_ the one that\r\nran on the hardware. The key here is to emulate the _parts_ or peripherals that\r\nare hooked to the AVR. Of course, you don't have to emulate the full hardware, you just\r\nneed to generate the proper stimulus so that the AVR is fooled.\r\n\r\nHD44780 LCD Board Demo\r\n----------------------\r\n\r\n![lcd](https://github.com/buserror-uk/simavr/raw/master/doc/img/hd44780.png)\r\n\r\nThis example board hooks up an Atmega48 to an emulated HD44780 LCD and display a running\r\ncounter in the 'lcd'. Everything is emulated, the firmware runs exactly like this\r\non a real hardware.\r\n\r\n![lcd-gtkwave](https://github.com/buserror-uk/simavr/raw/master/doc/img/hd44780-wave.png)\r\n\r\nAnd this is a gtkwave trace of what the firmware is doing. You can zoom in, measure, etc\r\nin gtkwave, select trades to see etc.\r\n\r\nQuite a few other examples are available!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}